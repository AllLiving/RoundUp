---

---


##<center>嵌入式系统导论实验报告
-------

|  姓名  |    学号    |  班级  |     电话      |        邮箱         |
| :--: | :------: | :--: | :---------: | :---------------: |
| 曹广杰  | 15352015 | 1501 | 13727022190 | 1553118845@qq.com |

-----


###1.实验题目

<center><font size=5>lab1 死锁</font></center >

###2.实验结果

<div align = center>

![mm](C:\Users\Cedar\Desktop\mm.png)

</div>

###3.实验心得

<font size = 3>

&ensp;本次实验中使用Java语言进行双线程的输出操作，使之出现死锁状态。对于本次实验的感想，笔者以实验过程中思考问题的方式进行阐述：

Q1：
为什么会死锁；

Ans1：

&emsp;&emsp;两个实例化参数a, b， 输出时候b需要等待a，而ab调用的时间间隔相近，导致二者可能会同时互相调用对方；

&emsp;由于实例化对象的函数都设置为同步的，导致只有在该实例空闲时才可以被调用其函数，因此两个线程只能先运行一个，通常情况下是b等待a；随着运行过程的进行，二者输出的时间差距越来越小，以至于出现了资源抢占导致的死锁；

Q2：
为什么在取消其中一个同步的时候，不会死锁，但是输出时会ab线程交叉呢？

Ans2：

&emsp;同步操作意味着，该实例化对象在调用一个函数的时候不可以调用其他的函数；
取消其中一个同步操作，就不能形成“b等待a时，a和b的last函数都不能运行的状态”，那么ab之间的时间间隔将会或长或短，形成输出信息交替变换的状态。

Q3：
为什么即使ab交叉输出，输出文字也不会互相干扰呢？

Ans：

###### &emsp;输出文字互相干扰只能说明没有同时输出，既然在输出过程中没有加锁，软资源限制，那就只能说明输出的信息太少而线程运行的时间间隔很长，想必之下，输出过程俨然就是瞬息之间，故而形成原子化效果；

###### Q4：死锁产生的四个条件：

ans：

互斥条件：一个资源每次只能被一个进程使用 

请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 

不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺 

循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

###### </font>